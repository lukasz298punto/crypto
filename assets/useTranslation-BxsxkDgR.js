import{r as i,a as L,j as P,H as J,I as W}from"./index-X_hScAMt.js";import{a as k,g as F,b as $,P as Y,c as O,e as A}from"./Stack-DTH2VSBZ.js";function q(e){return F("MuiCard",e)}k("MuiCard",["root"]);const K=e=>{const{classes:t}=e;return A({root:["root"]},q,t)},Q=$(Y,{name:"MuiCard",slot:"Root",overridesResolver:(e,t)=>t.root})({overflow:"hidden"}),ie=i.forwardRef(function(t,n){const o=L({props:t,name:"MuiCard"}),{className:c,raised:s=!1,...l}=o,g={...o,raised:s},m=K(g);return P.jsx(Q,{className:O(m.root,c),elevation:s?8:void 0,ref:n,ownerState:g,...l})});function X(e){return F("MuiCardContent",e)}k("MuiCardContent",["root"]);const Z=e=>{const{classes:t}=e;return A({root:["root"]},X,t)},_=$("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:16,"&:last-child":{paddingBottom:24}}),ce=i.forwardRef(function(t,n){const o=L({props:t,name:"MuiCardContent"}),{className:c,component:s="div",...l}=o,g={...o,component:s},m=Z(g);return P.jsx(_,{as:s,className:O(m.root,c),ownerState:g,ref:n,...l})}),D=(...e)=>{console!=null&&console.warn&&(N(e[0])&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e))},j={},R=(...e)=>{N(e[0])&&j[e[0]]||(N(e[0])&&(j[e[0]]=new Date),D(...e))},B=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout(()=>{e.off("initialized",n)},0),t()};e.on("initialized",n)}},z=(e,t,n)=>{e.loadNamespaces(t,B(e,n))},I=(e,t,n,o)=>{N(n)&&(n=[n]),n.forEach(c=>{e.options.ns.indexOf(c)<0&&e.options.ns.push(c)}),e.loadLanguages(t,B(e,o))},V=(e,t,n={})=>!t.languages||!t.languages.length?(R("i18n.languages were undefined or empty",t.languages),!0):t.hasLoadedNamespace(e,{lng:n.lng,precheck:(o,c)=>{var s;if(((s=n.bindI18n)==null?void 0:s.indexOf("languageChanging"))>-1&&o.services.backendConnector.backend&&o.isLanguageChangingTo&&!c(o.isLanguageChangingTo,e))return!1}}),N=e=>typeof e=="string",ee=e=>typeof e=="object"&&e!==null,te=i.createContext();class se{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(n=>{var o;(o=this.usedNamespaces)[n]??(o[n]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const ne=(e,t)=>{const n=i.useRef();return i.useEffect(()=>{n.current=e},[e,t]),n.current},G=(e,t,n,o)=>e.getFixedT(t,n,o),oe=(e,t,n,o)=>i.useCallback(G(e,t,n,o),[e,t,n,o]),le=(e,t={})=>{var M,T,E,U;const{i18n:n}=t,{i18n:o,defaultNS:c}=i.useContext(te)||{},s=n||o||W();if(s&&!s.reportNamespaces&&(s.reportNamespaces=new se),!s){R("You will need to pass in an i18next instance by using initReactI18next");const r=(d,f)=>N(f)?f:ee(f)&&N(f.defaultValue)?f.defaultValue:Array.isArray(d)?d[d.length-1]:d,u=[r,{},!1];return u.t=r,u.i18n={},u.ready=!1,u}(M=s.options.react)!=null&&M.wait&&R("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const l={...J(),...s.options.react,...t},{useSuspense:g,keyPrefix:m}=l;let a=c||((T=s.options)==null?void 0:T.defaultNS);a=N(a)?[a]:a||["translation"],(U=(E=s.reportNamespaces).addUsedNamespaces)==null||U.call(E,a);const C=(s.isInitialized||s.initializedStoreOnce)&&a.every(r=>V(r,s,l)),H=oe(s,t.lng||null,l.nsMode==="fallback"?a:a[0],m),S=()=>H,x=()=>G(s,t.lng||null,l.nsMode==="fallback"?a:a[0],m),[b,y]=i.useState(S);let h=a.join();t.lng&&(h=`${t.lng}${h}`);const v=ne(h),p=i.useRef(!0);i.useEffect(()=>{const{bindI18n:r,bindI18nStore:u}=l;p.current=!0,!C&&!g&&(t.lng?I(s,t.lng,a,()=>{p.current&&y(x)}):z(s,a,()=>{p.current&&y(x)})),C&&v&&v!==h&&p.current&&y(x);const d=()=>{p.current&&y(x)};return r&&(s==null||s.on(r,d)),u&&(s==null||s.store.on(u,d)),()=>{p.current=!1,s&&(r==null||r.split(" ").forEach(f=>s.off(f,d))),u&&s&&u.split(" ").forEach(f=>s.store.off(f,d))}},[s,h]),i.useEffect(()=>{p.current&&C&&y(S)},[s,m,C]);const w=[b,s,C];if(w.t=b,w.i18n=s,w.ready=C,C||!C&&!g)return w;throw new Promise(r=>{t.lng?I(s,t.lng,a,()=>r()):z(s,a,()=>r())})};export{ie as C,ce as a,le as u};
